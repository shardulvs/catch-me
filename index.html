<!doctype html>
<html lang="en">
  <head>
    <meta charset="UTF-8" />
    <title>Catch the Mouse</title>
    <style>
      body {
        text-align: center;
        font-family: sans-serif;
      }
      canvas {
        border: 1px solid #333;
        background: #fafafa;
        display: block;
        margin: 1em auto;
      }
      #info {
        margin-bottom: 0.5em;
      }
      #info span {
        margin: 0 1em;
      }
    </style>
  </head>
  <body>
    <div id="info">
      <span>Level: <strong id="level">1</strong></span>
      <span>Top Speed: <strong id="topSpeed">—</strong> px/frame</span>
    </div>
    <canvas id="gameCanvas" width="800" height="600"></canvas>

    <script>
      (function () {
        // ── CONFIG ─────────────────────────────────────────────────────
        const BASE_SPEED = 1.0; // px/frame @ level 1
        const SPEED_INC = 0.5; // +px/frame per level
        const CATCH_DIST = 15; // px to catch
        const CURSOR_RADIUS = 6; // px

        // WALL PARAMETERS
        const MARGIN = 40;
        const NUM_WALLS = 12;
        const MIN_LEN = 120;
        const MAX_LEN = 240;
        const MIN_SEP = 60; // was 30 → larger overall gap
        const MIN_SEP_PARALLEL = 120; // extra gap for parallel lines
        const ORIENTS = [0, 45, 90, 135].map((d) => (d * Math.PI) / 180);
        const ANG_THRESH = (5 * Math.PI) / 180; // 5° tolerance

        // BOUNDARY AVOIDANCE
        const BOUND_AVOID = 80;
        const BOUND_FORCE = 1.5;

        // VELOCITY SMOOTHING
        const SMOOTHING_FACTOR = 0.8;

        // ── CANVAS & STATE ────────────────────────────────────────────
        const canvas = document.getElementById("gameCanvas"),
          ctx = canvas.getContext("2d"),
          W = canvas.width,
          H = canvas.height;

        let level = 1,
          topSpeed = BASE_SPEED,
          walls = [],
          mousePos = { x: W / 2, y: H / 2 },
          mouseVel = { x: 0, y: 0 },
          cursorPos = { x: 0, y: 0 },
          lastCursor = { x: 0, y: 0, t: performance.now() },
          cursorSpeed = 0,
          allowCatch = false;

        // Wander
        let wanderTarget = { x: W / 2, y: H / 2 },
          wanderTime = 0;

        // UI refs
        const levelEl = document.getElementById("level"),
          topSpeedEl = document.getElementById("topSpeed");

        // ── UTILS ──────────────────────────────────────────────────────
        const rand = (a, b) => a + Math.random() * (b - a);

        function segIntersect(p1, p2, p3, p4) {
          const o = (a, b, c) =>
            (b.x - a.x) * (c.y - a.y) - (b.y - a.y) * (c.x - a.x);
          const o1 = o(p1, p2, p3),
            o2 = o(p1, p2, p4),
            o3 = o(p3, p4, p1),
            o4 = o(p3, p4, p2);
          return o1 * o2 < 0 && o3 * o4 < 0;
        }

        function distPointSeg(p, a, b) {
          const vx = b.x - a.x,
            vy = b.y - a.y,
            wx = p.x - a.x,
            wy = p.y - a.y;
          const t = (vx * wx + vy * wy) / (vx * vx + vy * vy);
          const cx = t < 0 ? a.x : t > 1 ? b.x : a.x + t * vx;
          const cy = t < 0 ? a.y : t > 1 ? b.y : a.y + t * vy;
          return Math.hypot(p.x - cx, p.y - cy);
        }

        // reflect velocity off wall's normal
        function reflectVelocity(vel, wall) {
          const wx = wall.B.x - wall.A.x,
            wy = wall.B.y - wall.A.y;
          const len = Math.hypot(wx, wy) || 1;
          const nx = -wy / len,
            ny = wx / len;
          const dot = vel.x * nx + vel.y * ny;
          return {
            x: vel.x - 2 * dot * nx,
            y: vel.y - 2 * dot * ny,
          };
        }

        // ── NEW: OFFSCREEN MASK‐BASED WALL GENERATION ────────────────
        const MASK_BUFFER = MIN_SEP; // how far from an existing wall is forbidden

        function overlapsMask(A, B, maskCtx) {
          // sample along the segment; if any pixel in the mask has alpha>0, we collide
          const steps = 20;
          for (let i = 0; i <= steps; i++) {
            const t = i / steps;
            const x = Math.floor(A.x + (B.x - A.x) * t);
            const y = Math.floor(A.y + (B.y - A.y) * t);
            const pix = maskCtx.getImageData(x, y, 1, 1).data;
            if (pix[3] > 0) return true;
          }
          return false;
        }

        function generateWalls() {
          // 1) create offscreen mask
          const maskCan = document.createElement("canvas");
          maskCan.width = W;
          maskCan.height = H;
          const maskCtx = maskCan.getContext("2d");

          // 2) mark the edge‐margin as forbidden
          maskCtx.fillStyle = "rgba(255,255,255,1)";
          maskCtx.fillRect(0, 0, W, MARGIN);
          maskCtx.fillRect(0, H - MARGIN, W, MARGIN);
          maskCtx.fillRect(0, 0, MARGIN, H);
          maskCtx.fillRect(W - MARGIN, 0, MARGIN, H);

          walls = [];
          let tries = 0;
          while (walls.length < NUM_WALLS && tries++ < 5000) {
            // pick orientation & length
            const θ = ORIENTS[Math.floor(Math.random() * ORIENTS.length)];
            const len = rand(MIN_LEN, MAX_LEN);
            const dx = (Math.cos(θ) * len) / 2,
              dy = (Math.sin(θ) * len) / 2;
            const cx = rand(MARGIN + Math.abs(dx), W - MARGIN - Math.abs(dx));
            const cy = rand(MARGIN + Math.abs(dy), H - MARGIN - Math.abs(dy));
            const A = { x: cx - dx, y: cy - dy };
            const B = { x: cx + dx, y: cy + dy };

            // reject if it hits any forbidden (masked) pixel
            if (overlapsMask(A, B, maskCtx)) continue;

            // accept it
            walls.push({ A, B, theta: θ });

            // now “color” its BUFFER‐zone onto the mask
            maskCtx.strokeStyle = "rgba(255,255,255,1)";
            maskCtx.lineWidth = MASK_BUFFER * 2;
            maskCtx.beginPath();
            maskCtx.moveTo(A.x, A.y);
            maskCtx.lineTo(B.x, B.y);
            maskCtx.stroke();
          }
        }

        // ── end of new wall‐generation block ───────────────────────────

        // ── LEVEL & UI ─────────────────────────────────────────────────
        function updateUI() {
          levelEl.textContent = level;
          topSpeedEl.textContent = topSpeed.toFixed(2);
        }

        function nextLevel() {
          level++;
          topSpeed = BASE_SPEED + SPEED_INC * (level - 1);
          resetRound();
        }

        function gameOver() {
          alert(
            "Game Over! You hit a wall or the mouse escaped. Back to level 1.",
          );
          level = 1;
          topSpeed = BASE_SPEED;
          resetRound();
        }

        function resetRound() {
          mousePos = { x: W / 2, y: H / 2 };
          mouseVel = { x: 0, y: 0 };
          allowCatch = false;
          wanderTarget = {
            x: rand(MARGIN, W - MARGIN),
            y: rand(MARGIN, H - MARGIN),
          };
          wanderTime = rand(2, 5);
          generateWalls();
          updateUI();
        }

        // ── WANDER ──────────────────────────────────────────────────────
        function updateWander(dt) {
          wanderTime -= dt;
          if (wanderTime <= 0) {
            wanderTarget = {
              x: rand(MARGIN, W - MARGIN),
              y: rand(MARGIN, H - MARGIN),
            };
            wanderTime = rand(2, 5);
          }
        }

        // ── MOUSE AI + COLLISIONS ──────────────────────────────────────
        function updateMouse(dt) {
          const oldPos = { ...mousePos };

          // 1) flee
          let fx = mousePos.x - cursorPos.x,
            fy = mousePos.y - cursorPos.y;
          const fd = Math.hypot(fx, fy) || 1;
          fx /= fd;
          fy /= fd;

          // 2) wall avoidance
          let ax = 0,
            ay = 0;
          const AVOID_DIST = 60;
          for (let w of walls) {
            const a = w.A,
              b = w.B;
            const vx = b.x - a.x,
              vy = b.y - a.y;
            const wx = mousePos.x - a.x,
              wy = mousePos.y - a.y;
            const t = (vx * wx + vy * wy) / (vx * vx + vy * vy);
            const cx = t < 0 ? a.x : t > 1 ? b.x : a.x + t * vx;
            const cy = t < 0 ? a.y : t > 1 ? b.y : a.y + t * vy;
            const dist = Math.hypot(mousePos.x - cx, mousePos.y - cy);
            if (dist < AVOID_DIST) {
              let rx = mousePos.x - cx || 1,
                ry = mousePos.y - cy || 1;
              const rlen = Math.hypot(rx, ry);
              rx /= rlen;
              ry /= rlen;
              const s = (AVOID_DIST - dist) / AVOID_DIST;
              ax += rx * s;
              ay += ry * s;
            }
          }

          // 3) boundary avoidance
          let bx = 0,
            by = 0;
          if (mousePos.x < BOUND_AVOID)
            bx += (BOUND_AVOID - mousePos.x) / BOUND_AVOID;
          if (mousePos.x > W - BOUND_AVOID)
            bx -= (mousePos.x - (W - BOUND_AVOID)) / BOUND_AVOID;
          if (mousePos.y < BOUND_AVOID)
            by += (BOUND_AVOID - mousePos.y) / BOUND_AVOID;
          if (mousePos.y > H - BOUND_AVOID)
            by -= (mousePos.y - (H - BOUND_AVOID)) / BOUND_AVOID;
          ax += bx * BOUND_FORCE;
          ay += by * BOUND_FORCE;

          // 4) wander
          updateWander(dt);
          let tx = wanderTarget.x - mousePos.x,
            ty = wanderTarget.y - mousePos.y;
          const td = Math.hypot(tx, ty) || 1;
          tx /= td;
          ty /= td;

          // 5) jitter – small normally, big if almost stalled
          const speedEst = Math.hypot(mouseVel.x, mouseVel.y);
          const JITTER_SMALL = 0.0,
            JITTER_BIG = 0.0;
          const jitterMag =
            speedEst < topSpeed * 0.3 ? JITTER_BIG : JITTER_SMALL;
          const jx = (Math.random() * 2 - 1) * jitterMag;
          const jy = (Math.random() * 2 - 1) * jitterMag;

          // 6) combine & normalize
          const FLEE_W = 1.2,
            AVOID_W = 1.0,
            WANDER_W = 0.6;
          let vx = fx * FLEE_W + ax * AVOID_W + tx * WANDER_W + jx,
            vy = fy * FLEE_W + ay * AVOID_W + ty * WANDER_W + jy;
          const vlen = Math.hypot(vx, vy) || 1;
          vx /= vlen;
          vy /= vlen;

          // 7) speed
          const k = 0.2,
            speed = Math.min(topSpeed + k * cursorSpeed, topSpeed * 1.5);

          let newVel = { x: vx * speed, y: vy * speed },
            newPos = { x: oldPos.x + newVel.x, y: oldPos.y + newVel.y };

          // 8) wall collision & reflect
          for (let w of walls) {
            if (segIntersect(oldPos, newPos, w.A, w.B)) {
              newVel = reflectVelocity(newVel, w);
              newVel.x *= 0.5;
              newVel.y *= 0.5;
              newPos = { x: oldPos.x + newVel.x, y: oldPos.y + newVel.y };
              break;
            }
          }

          // 9) smoothing
          mouseVel.x =
            mouseVel.x * SMOOTHING_FACTOR + newVel.x * (1 - SMOOTHING_FACTOR);
          mouseVel.y =
            mouseVel.y * SMOOTHING_FACTOR + newVel.y * (1 - SMOOTHING_FACTOR);
          mousePos.x = oldPos.x + mouseVel.x;
          mousePos.y = oldPos.y + mouseVel.y;

          // 10) clamp & bounce edges
          if (mousePos.x < 0) {
            mousePos.x = 0;
            mouseVel.x *= -0.5;
          }
          if (mousePos.x > W) {
            mousePos.x = W;
            mouseVel.x *= -0.5;
          }
          if (mousePos.y < 0) {
            mousePos.y = 0;
            mouseVel.y *= -0.5;
          }
          if (mousePos.y > H) {
            mousePos.y = H;
            mouseVel.y *= -0.5;
          }
        }

        // ── RENDER ─────────────────────────────────────────────────────
        function draw() {
          ctx.clearRect(0, 0, W, H);
          // walls
          ctx.strokeStyle = "#333";
          ctx.lineWidth = 4;
          walls.forEach((w) => {
            ctx.beginPath();
            ctx.moveTo(w.A.x, w.A.y);
            ctx.lineTo(w.B.x, w.B.y);
            ctx.stroke();
          });
          // mouse
          ctx.fillStyle = "gray";
          ctx.beginPath();
          ctx.arc(mousePos.x, mousePos.y, 10, 0, 2 * Math.PI);
          ctx.fill();
          // cursor
          ctx.fillStyle = "red";
          ctx.beginPath();
          ctx.arc(cursorPos.x, cursorPos.y, CURSOR_RADIUS, 0, 2 * Math.PI);
          ctx.fill();
        }

        // ── MAIN LOOP ──────────────────────────────────────────────────
        let lastTime = performance.now();
        (function loop(now) {
          const dt = (now - lastTime) / 1000;
          lastTime = now;

          updateMouse(dt);
          draw();

          if (allowCatch) {
            const dx = mousePos.x - cursorPos.x,
              dy = mousePos.y - cursorPos.y;
            if (Math.hypot(dx, dy) < CATCH_DIST) {
              nextLevel();
            }
          }

          requestAnimationFrame(loop);
        })(lastTime);

        // ── CURSOR TRACKING & GAME OVER ────────────────────────────────
        canvas.addEventListener("mousemove", (e) => {
          const r = canvas.getBoundingClientRect();
          const x = e.clientX - r.left,
            y = e.clientY - r.top;
          const t = performance.now(),
            dt = (t - lastCursor.t) / 1000;
          cursorSpeed =
            dt > 0 ? Math.hypot(x - lastCursor.x, y - lastCursor.y) / dt : 0;
          cursorPos = { x, y };

          // touch a wall → game over
          for (let w of walls) {
            if (distPointSeg(cursorPos, w.A, w.B) < CURSOR_RADIUS) {
              return gameOver();
            }
          }

          // arm the catch once you’ve backed off
          if (!allowCatch) {
            const md = Math.hypot(mousePos.x - x, mousePos.y - y);
            if (md > CATCH_DIST * 2) allowCatch = true;
          }

          lastCursor = { x, y, t };
        });

        // ── INIT ───────────────────────────────────────────────────────
        resetRound();
      })();
    </script>
  </body>
</html>
